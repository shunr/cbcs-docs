{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to Colonel By CS Docs\n\n\nIntroduction\n\n\nCompetitive programming is very fun and not hard at all to get into. It gives a great feeling of satisfaction upon answering a question correctly. We have only been practicing for half a year and are already quite experienced. If you find it interesting and put in the work, you can easily be top level competitors (CCO)\n\n\nWe all use both C++ and Python when solving problems. The two languages we would most recommend are C++ and Java. C++ has much less verbose syntax and is thus faster to write in most cases.\n\n\nThis is the order in which we learned concepts. There is no perfect order to follow, however some topics are much easier when you know others.\n\n\nImplementation (become familiar and comfortable with a language)\nRecursion\nUnderstanding basic graph theory and Breadth First Search/Depth First Search\nGreedy algorithms\nDynamic Programming\nSingle Source Shortest Path (Dijkstra\u2019s and Bellman-Ford)\nLearn about different containers (learn standard libraries, they\u2019re very powerful)\nMinimum Spanning Trees\nData Structures (Binary Indexed Tree, Segment Tree, Binary Search Tree)\nMax flow MIN CUT LEMMA WOOOOO MATHEMATICS",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-colonel-by-cs-docs",
            "text": "Introduction  Competitive programming is very fun and not hard at all to get into. It gives a great feeling of satisfaction upon answering a question correctly. We have only been practicing for half a year and are already quite experienced. If you find it interesting and put in the work, you can easily be top level competitors (CCO)  We all use both C++ and Python when solving problems. The two languages we would most recommend are C++ and Java. C++ has much less verbose syntax and is thus faster to write in most cases.  This is the order in which we learned concepts. There is no perfect order to follow, however some topics are much easier when you know others.  Implementation (become familiar and comfortable with a language)\nRecursion\nUnderstanding basic graph theory and Breadth First Search/Depth First Search\nGreedy algorithms\nDynamic Programming\nSingle Source Shortest Path (Dijkstra\u2019s and Bellman-Ford)\nLearn about different containers (learn standard libraries, they\u2019re very powerful)\nMinimum Spanning Trees\nData Structures (Binary Indexed Tree, Segment Tree, Binary Search Tree)\nMax flow MIN CUT LEMMA WOOOOO MATHEMATICS",
            "title": "Welcome to Colonel By CS Docs"
        },
        {
            "location": "/recursion/",
            "text": "Recursion\n\n\n\n\nRecursion is a fundamental concept that is incredibly useful in competitive programming. It is commonly used to solve problems in graph theory and implemented in algorithms such as \ndepth and beadth first search\n. Recursion also provides a very simple and straightforward way of thinking about \ndynamic programming\n. Recursion is very powerful and necessary for many problems.\n\n\nThe idea with recursion is that a function will be called, but in order to return a value it relies on the same function being called. It will continue to \u201cwait\u201d until a base case is reached, where afterwards all of the other functions can return values.\n\n\nExample\n\n\nA common example is a recursive solution to finding the \nn\nth Fibonacci number\n\n\nfib(n) {\n    if (n == 0 || n == 1)\n        return 1\n    return fib(n-1) + fib(n-2)\n}\n\n\n\n\nExplanation\n\n\nThis function begins with the parameter \nn\n, the answer in the first call of the function depends on the previous two Fibonacci numbers since \nfib(n) = fib(n-1) + fib(n-2)\n. This means that the function will be executed again to solve for these two numbers, since none of these numbers are known yet, it will continue calling this function until the base case is reached. In mathematical terms, the Fibonacci sequence is based on a formula that is based on the first and second terms. In math class you have probably learned about such recursive sequences, the value of the next term depends on the current term or terms.\n\n\nPractice problems\n\n\n\n\nCCC '13 S3 - Chances of Winning\n\n\nVM7WC '16 #4 Silver - Tests or Test Cases?\n\n\nCCC '96 S3 - Pattern Generator\n\n\nCCC '03 S3 - Floor Plan\n *\nincludes graph theory",
            "title": "Recursion"
        },
        {
            "location": "/recursion/#recursion",
            "text": "Recursion is a fundamental concept that is incredibly useful in competitive programming. It is commonly used to solve problems in graph theory and implemented in algorithms such as  depth and beadth first search . Recursion also provides a very simple and straightforward way of thinking about  dynamic programming . Recursion is very powerful and necessary for many problems.  The idea with recursion is that a function will be called, but in order to return a value it relies on the same function being called. It will continue to \u201cwait\u201d until a base case is reached, where afterwards all of the other functions can return values.",
            "title": "Recursion"
        },
        {
            "location": "/recursion/#example",
            "text": "A common example is a recursive solution to finding the  n th Fibonacci number  fib(n) {\n    if (n == 0 || n == 1)\n        return 1\n    return fib(n-1) + fib(n-2)\n}",
            "title": "Example"
        },
        {
            "location": "/recursion/#explanation",
            "text": "This function begins with the parameter  n , the answer in the first call of the function depends on the previous two Fibonacci numbers since  fib(n) = fib(n-1) + fib(n-2) . This means that the function will be executed again to solve for these two numbers, since none of these numbers are known yet, it will continue calling this function until the base case is reached. In mathematical terms, the Fibonacci sequence is based on a formula that is based on the first and second terms. In math class you have probably learned about such recursive sequences, the value of the next term depends on the current term or terms.",
            "title": "Explanation"
        },
        {
            "location": "/recursion/#practice-problems",
            "text": "CCC '13 S3 - Chances of Winning  VM7WC '16 #4 Silver - Tests or Test Cases?  CCC '96 S3 - Pattern Generator  CCC '03 S3 - Floor Plan  * includes graph theory",
            "title": "Practice problems"
        },
        {
            "location": "/dp/",
            "text": "Dynamic Programming\n\n\nDynamic Programming is a very important topic in competitive programming, showing up often on contests. Dynamic Programming simply means the use of \nsubproblems\n in order to solve a larger problem. This involves calculating and storing the result of the correct answer for a certain subproblem and reusing it when combined with other subproblems.\n\n\nImplementation\n\n\nA simple example of the effectiveness of DP is when computing the \nn\nth Fibonacci number.\n\n\nRecursive approach\n\n\nA naive recursive solution would need to calculate \nfib(x)\n every single time \nfib(x)\n is called for every number \nx\n, making the approach extremely slow when \nn\n is large.\n\n\nfib(n) {\nif (n == 0 || n == 1)\n    return 1\nreturn fib(n-1) + fib(n-2) // We are calculating fib(n-2) every time\n\n\n\n\nDP approach\n\n\nA solution using dynamic programming just stores the results of the Fibonacci numbers after being computed, treating \nfib(n-1)\n as the subproblem.\n\n\nmemo = {} //dictionary, map or array\n\nfib(n) {\nif (memo[n] != -1) // It has already been calculateed\n    return memo[n]\nif (n == 0 || n == 1)\n    return 1\ntoReturn = fib(n-1) + fib(n-2)\nmemo[n] = toReturn //After calculating the result, store it for later use\nreturn toReturn\n\n\n\n\nThis solution now ensures that you no longer need to recalculate results that you have already made, saving a lot of time when solving multiple queries.\n\n\nIn dynamic programming, the subproblems often involve finding the solution for a prefix, suffix or subset of an array or set of numbers.\n\n\nResources\n\n\nGreat resources for learning dynamic programming by MIT Open Courseware:\n- \nDynamic Programming I\n\n- \nDynamic Programming II\n\n- \nDynamic Programming III\n\n\nMore advanced concepts with bitmasking\n- \nHackerEarth DP Bitmasking",
            "title": "Dynamic Programming"
        },
        {
            "location": "/dp/#dynamic-programming",
            "text": "Dynamic Programming is a very important topic in competitive programming, showing up often on contests. Dynamic Programming simply means the use of  subproblems  in order to solve a larger problem. This involves calculating and storing the result of the correct answer for a certain subproblem and reusing it when combined with other subproblems.",
            "title": "Dynamic Programming"
        },
        {
            "location": "/dp/#implementation",
            "text": "A simple example of the effectiveness of DP is when computing the  n th Fibonacci number.",
            "title": "Implementation"
        },
        {
            "location": "/dp/#recursive-approach",
            "text": "A naive recursive solution would need to calculate  fib(x)  every single time  fib(x)  is called for every number  x , making the approach extremely slow when  n  is large.  fib(n) {\nif (n == 0 || n == 1)\n    return 1\nreturn fib(n-1) + fib(n-2) // We are calculating fib(n-2) every time",
            "title": "Recursive approach"
        },
        {
            "location": "/dp/#dp-approach",
            "text": "A solution using dynamic programming just stores the results of the Fibonacci numbers after being computed, treating  fib(n-1)  as the subproblem.  memo = {} //dictionary, map or array\n\nfib(n) {\nif (memo[n] != -1) // It has already been calculateed\n    return memo[n]\nif (n == 0 || n == 1)\n    return 1\ntoReturn = fib(n-1) + fib(n-2)\nmemo[n] = toReturn //After calculating the result, store it for later use\nreturn toReturn  This solution now ensures that you no longer need to recalculate results that you have already made, saving a lot of time when solving multiple queries.  In dynamic programming, the subproblems often involve finding the solution for a prefix, suffix or subset of an array or set of numbers.",
            "title": "DP approach"
        },
        {
            "location": "/dp/#resources",
            "text": "Great resources for learning dynamic programming by MIT Open Courseware:\n-  Dynamic Programming I \n-  Dynamic Programming II \n-  Dynamic Programming III  More advanced concepts with bitmasking\n-  HackerEarth DP Bitmasking",
            "title": "Resources"
        },
        {
            "location": "/graph/",
            "text": "Graph Theory\n\n\nGraph theory is a topic that shows up commonly in competitive programming. \n\n\nA graph is a sort of map. You can imagine many nodes (houses, cities, other objects) which are interconnected by edges (roads). Graph theory aims to answer questions about the paths between these nodes.\n\n\nGraph Traversal\n\n\nBreadth First Search and Depth First Search are methods of traversing a graph that can be used to gather information such as if a specific node exists or to find a valid path to that node. \n\n\nBreadth First Search\n\n\nBFS visits all nodes one \u201clayer\u201d at a time. Starting at the root it looks at all child nodes of the root. Afterwards, for each of these children, it will perform the same action, it will check all the children of the children of the root. It is easier to understand with a picture:\n\n\n\n\nJava implmentation\n\n\nThe following is an example in Java of how to implement BFS. This is the solution to \nVM7WC '16 #3 Silver - Can Shahir even get there?!\n\n. After reaching a node, it adds all of its children and moves to the next node in the queue. This ensures that each layer will be opened one by one.\n\n\nimport java.util.*;\n\npublic class Main {\n\n  public static ArrayList<ArrayList<Integer>> graph = new ArrayList<ArrayList<Integer>>();\n\n  static Scanner scan = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int n, m, a, b;\n    n = scan.nextInt();\n    m = scan.nextInt();\n    a = scan.nextInt();\n    b = scan.nextInt();\n\n    //Creating a graph using adjacency lists\n    //In this case the houses (nodes) are numbers, so you can just use arraylists/arrays\n    //If the nodes are strings, you pretty much have to use a HashMap\n\n    for (int i = 0; i <= n; i ++) { //Creating new arraylists for each possible node (n nodes)\n      graph.add(new ArrayList<Integer>());\n    }\n\n    int x, y;\n\n    for (int i = 0; i < m; i ++) {\n      x = scan.nextInt();\n      y = scan.nextInt();\n      graph.get(x).add(y); //adds the adjacent node (neighbor) to the graph\n      graph.get(y).add(x); //adds the connection the other way\n      //Means that x will be connnected to y and y will be connceted to x\n    }\n\n    if (BFS(a,b))\n      System.out.println(\"GO SHAHIR!\");\n    else\n      System.out.println(\"NO SHAHIR!\");\n  }\n\n  //BFS will start at the start node, and check all the nodes beside it\n  //It adds those nodes to the queue, and then spreads out again\n  // Keeps expanding one \"layer\" at a time until the target is seen or until there's nothing left to check\n  public static boolean BFS(int start, int end) {\n    ArrayDeque<ArrayList<Integer>> queue = new ArrayDeque<>(); //Double ended queue, similar functions as arraylist, faster pop from front though\n    HashSet<Integer> visited = new HashSet<>(); //stores visited nodes\n    ArrayList<Integer> temp = new ArrayList<Integer>();\n    temp.add(start); //Creates a temporary \"path\" containing only the start node\n    queue.add(temp);\n\n    while(queue.size() != 0){ //If the queue is not empty\n        ArrayList<Integer> path = queue.poll(); //Gets the first path in the queue\n        int node = path.get(path.size()-1); //Gets the last node in the path\n\n        if (node == end) { //If you've found the target\n          return true;\n        }\n\n        if(!visited.contains(node)){ //If vertex hasn't already been visited\n            for (int adj: graph.get(node)) { //Checks all neighbor nodes\n              ArrayList<Integer> newpath = new ArrayList<Integer>(path); //Copies the current path IMPORTANT TO DO THIS CONSTUCTOR COPY OR IT WILL POINT TO SAME MEMORY\n              newpath.add(adj); //Adds the neighboring node to the path\n              queue.add(newpath); //Adds the new path into the queue\n            }\n            visited.add(node); //Adds the node to visited\n        }\n    }\n\n    return false; //Queue is empty, all nodes have been checked, no possible path\n  }\n}\n\n\n\n\nDepth First Search\n\n\nDFS continues visiting the first (or leftmost) child of each node until there are no more nodes. Afterwards, it returns to the parent of the last node in the path, and visits the rest of it\u2019s children. It goes as deep as possible down each path, and then moves up one layer and checks as deep as possible again. It is easier to understand with a picture.\n\n\n\n\nDepth first search can be written iteratively by changing one line of iterative breadth first search.\n\n\n\n\nHint: you can then switch the deque to a simple vector\n\n\n\n\nDFS can also be written recursively.\n\n\nDFS(start,end,path) {\n    // In python recursion you must copy the path since it passes by reference\n    // otherwise it will be passed a copy in C++ and Java\n    path = path + [start] // Python\n    path.push(start) // Other languages\n    if (start == end)\n        return path\n    if (graph[start].size == 0) // Reached the end of a path (a leaf)\n        return [] // No path possible\n    for each node in graph[start] { // For-each loop through all children of the current node\n        if (node not in path) { // Do not go backwards in the path\n            newpath = DFS(node,end,path)\n            if newpath != [] // If a path to the end if found\n                return newpath\n    return [] // If nothing is found return nothing\n}\n\n\n\n\nDijkstra's Algorithm\n\n\nIn many cases, you are trying to find the shortest path from a single source to a destination given that each edge between nodes have different lengths or \nweights\n. This common problem, often known as finding the \nSingle Source Shortest Path\n, can be solved using Dijkstra's algorithm.\n\n\nMIT OpenCourseware\n\n\n\n\nImplementation\n\n\nBelow is a partial Python solution to \nSingle Source Shortest Path\n using Dijkstra's.\n\n\n```python\ndef dijkstras(Graph, weights, source):\n    distances = {}\n    for i in Graph:\n        distances[i] = inf\n    q, visited = [(0, source)], set() \n    distances[source] = 0\n    while q:\n        (dist, v1) = heappop(q)\n        if v1 in visited:\n            continue\n        visited.add(v1)\n        for v2 in Graph[v1]:\n            if v2 not in visited:\n                newd = dist + weights[(v1, v2)] \n                heappush(q, (dist + weights[(v1, v2)], v2))\n            if distances[v2] > newd:\n                distances[v2] = newd\n  return distances",
            "title": "Graph Theory"
        },
        {
            "location": "/graph/#graph-theory",
            "text": "Graph theory is a topic that shows up commonly in competitive programming.   A graph is a sort of map. You can imagine many nodes (houses, cities, other objects) which are interconnected by edges (roads). Graph theory aims to answer questions about the paths between these nodes.",
            "title": "Graph Theory"
        },
        {
            "location": "/graph/#graph-traversal",
            "text": "Breadth First Search and Depth First Search are methods of traversing a graph that can be used to gather information such as if a specific node exists or to find a valid path to that node.",
            "title": "Graph Traversal"
        },
        {
            "location": "/graph/#breadth-first-search",
            "text": "BFS visits all nodes one \u201clayer\u201d at a time. Starting at the root it looks at all child nodes of the root. Afterwards, for each of these children, it will perform the same action, it will check all the children of the children of the root. It is easier to understand with a picture:",
            "title": "Breadth First Search"
        },
        {
            "location": "/graph/#java-implmentation",
            "text": "The following is an example in Java of how to implement BFS. This is the solution to  VM7WC '16 #3 Silver - Can Shahir even get there?! . After reaching a node, it adds all of its children and moves to the next node in the queue. This ensures that each layer will be opened one by one.  import java.util.*;\n\npublic class Main {\n\n  public static ArrayList<ArrayList<Integer>> graph = new ArrayList<ArrayList<Integer>>();\n\n  static Scanner scan = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int n, m, a, b;\n    n = scan.nextInt();\n    m = scan.nextInt();\n    a = scan.nextInt();\n    b = scan.nextInt();\n\n    //Creating a graph using adjacency lists\n    //In this case the houses (nodes) are numbers, so you can just use arraylists/arrays\n    //If the nodes are strings, you pretty much have to use a HashMap\n\n    for (int i = 0; i <= n; i ++) { //Creating new arraylists for each possible node (n nodes)\n      graph.add(new ArrayList<Integer>());\n    }\n\n    int x, y;\n\n    for (int i = 0; i < m; i ++) {\n      x = scan.nextInt();\n      y = scan.nextInt();\n      graph.get(x).add(y); //adds the adjacent node (neighbor) to the graph\n      graph.get(y).add(x); //adds the connection the other way\n      //Means that x will be connnected to y and y will be connceted to x\n    }\n\n    if (BFS(a,b))\n      System.out.println(\"GO SHAHIR!\");\n    else\n      System.out.println(\"NO SHAHIR!\");\n  }\n\n  //BFS will start at the start node, and check all the nodes beside it\n  //It adds those nodes to the queue, and then spreads out again\n  // Keeps expanding one \"layer\" at a time until the target is seen or until there's nothing left to check\n  public static boolean BFS(int start, int end) {\n    ArrayDeque<ArrayList<Integer>> queue = new ArrayDeque<>(); //Double ended queue, similar functions as arraylist, faster pop from front though\n    HashSet<Integer> visited = new HashSet<>(); //stores visited nodes\n    ArrayList<Integer> temp = new ArrayList<Integer>();\n    temp.add(start); //Creates a temporary \"path\" containing only the start node\n    queue.add(temp);\n\n    while(queue.size() != 0){ //If the queue is not empty\n        ArrayList<Integer> path = queue.poll(); //Gets the first path in the queue\n        int node = path.get(path.size()-1); //Gets the last node in the path\n\n        if (node == end) { //If you've found the target\n          return true;\n        }\n\n        if(!visited.contains(node)){ //If vertex hasn't already been visited\n            for (int adj: graph.get(node)) { //Checks all neighbor nodes\n              ArrayList<Integer> newpath = new ArrayList<Integer>(path); //Copies the current path IMPORTANT TO DO THIS CONSTUCTOR COPY OR IT WILL POINT TO SAME MEMORY\n              newpath.add(adj); //Adds the neighboring node to the path\n              queue.add(newpath); //Adds the new path into the queue\n            }\n            visited.add(node); //Adds the node to visited\n        }\n    }\n\n    return false; //Queue is empty, all nodes have been checked, no possible path\n  }\n}",
            "title": "Java implmentation"
        },
        {
            "location": "/graph/#depth-first-search",
            "text": "DFS continues visiting the first (or leftmost) child of each node until there are no more nodes. Afterwards, it returns to the parent of the last node in the path, and visits the rest of it\u2019s children. It goes as deep as possible down each path, and then moves up one layer and checks as deep as possible again. It is easier to understand with a picture.   Depth first search can be written iteratively by changing one line of iterative breadth first search.   Hint: you can then switch the deque to a simple vector   DFS can also be written recursively.  DFS(start,end,path) {\n    // In python recursion you must copy the path since it passes by reference\n    // otherwise it will be passed a copy in C++ and Java\n    path = path + [start] // Python\n    path.push(start) // Other languages\n    if (start == end)\n        return path\n    if (graph[start].size == 0) // Reached the end of a path (a leaf)\n        return [] // No path possible\n    for each node in graph[start] { // For-each loop through all children of the current node\n        if (node not in path) { // Do not go backwards in the path\n            newpath = DFS(node,end,path)\n            if newpath != [] // If a path to the end if found\n                return newpath\n    return [] // If nothing is found return nothing\n}",
            "title": "Depth First Search"
        },
        {
            "location": "/graph/#dijkstras-algorithm",
            "text": "In many cases, you are trying to find the shortest path from a single source to a destination given that each edge between nodes have different lengths or  weights . This common problem, often known as finding the  Single Source Shortest Path , can be solved using Dijkstra's algorithm.",
            "title": "Dijkstra's Algorithm"
        },
        {
            "location": "/graph/#mit-opencourseware",
            "text": "",
            "title": "MIT OpenCourseware"
        },
        {
            "location": "/graph/#implementation",
            "text": "Below is a partial Python solution to  Single Source Shortest Path  using Dijkstra's.  ```python\ndef dijkstras(Graph, weights, source):\n    distances = {}\n    for i in Graph:\n        distances[i] = inf\n    q, visited = [(0, source)], set() \n    distances[source] = 0\n    while q:\n        (dist, v1) = heappop(q)\n        if v1 in visited:\n            continue\n        visited.add(v1)\n        for v2 in Graph[v1]:\n            if v2 not in visited:\n                newd = dist + weights[(v1, v2)] \n                heappush(q, (dist + weights[(v1, v2)], v2))\n            if distances[v2] > newd:\n                distances[v2] = newd\n  return distances",
            "title": "Implementation"
        }
    ]
}