{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to Colonel By CS Docs\n\n\nIntroduction\n\n\nCompetitive programming is very fun and not hard at all to get into. It gives a great feeling of satisfaction upon answering a question correctly. We have only been practicing for half a year and are already quite experienced. If you find it interesting and put in the work, you can easily be top level competitors (CCO)\n\n\nWe all use both C++ and Python when solving problems. The two languages we would most recommend are C++ and Java. C++ has much less verbose syntax and is thus faster to write in most cases.\n\n\nThis is the order in which we learned concepts. There is no perfect order to follow, however some topics are much easier when you know others.\n\n\nImplementation (become familiar and comfortable with a language)\nRecursion\nUnderstanding basic graph theory and Breadth First Search/Depth First Search\nGreedy algorithms\nDynamic Programming\nSingle Source Shortest Path (Dijkstra\u2019s and Bellman-Ford)\nLearn about different containers (learn standard libraries, they\u2019re very powerful)\nMinimum Spanning Trees\nData Structures (Binary Indexed Tree, Segment Tree, Binary Search Tree)\nMax flow MIN CUT LEMMA WOOOOO MATHEMATICS",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-colonel-by-cs-docs",
            "text": "Introduction  Competitive programming is very fun and not hard at all to get into. It gives a great feeling of satisfaction upon answering a question correctly. We have only been practicing for half a year and are already quite experienced. If you find it interesting and put in the work, you can easily be top level competitors (CCO)  We all use both C++ and Python when solving problems. The two languages we would most recommend are C++ and Java. C++ has much less verbose syntax and is thus faster to write in most cases.  This is the order in which we learned concepts. There is no perfect order to follow, however some topics are much easier when you know others.  Implementation (become familiar and comfortable with a language)\nRecursion\nUnderstanding basic graph theory and Breadth First Search/Depth First Search\nGreedy algorithms\nDynamic Programming\nSingle Source Shortest Path (Dijkstra\u2019s and Bellman-Ford)\nLearn about different containers (learn standard libraries, they\u2019re very powerful)\nMinimum Spanning Trees\nData Structures (Binary Indexed Tree, Segment Tree, Binary Search Tree)\nMax flow MIN CUT LEMMA WOOOOO MATHEMATICS",
            "title": "Welcome to Colonel By CS Docs"
        },
        {
            "location": "/recursion/",
            "text": "Recursion\n\n\n\n\nRecursion is a fundamental concept that is incredibly useful in competitive programming. It is commonly used to solve problems in graph theory and implemented in algorithms such as \ndepth and beadth first search\n. Recursion also provides a very simple and straightforward way of thinking about \ndynamic programming\n. Recursion is very powerful and necessary for many problems.\n\n\nThe idea with recursion is that a function will be called, but in order to return a value it relies on the same function being called. It will continue to \u201cwait\u201d until a base case is reached, where afterwards all of the other functions can return values.\n\n\nExample\n\n\nA common example is a recursive solution to finding the \nn\nth Fibonacci number\n\n\nfib\n(\nn\n)\n \n{\n\n    \nif\n \n(\nn\n \n==\n \n0\n \n||\n \nn\n \n==\n \n1\n)\n\n        \nreturn\n \n1\n\n    \nreturn\n \nfib\n(\nn\n-\n1\n)\n \n+\n \nfib\n(\nn\n-\n2\n)\n\n\n}\n\n\n\n\n\n\nExplanation\n\n\nThis function begins with the parameter \nn\n, the answer in the first call of the function depends on the previous two Fibonacci numbers since \nfib(n) = fib(n-1) + fib(n-2)\n. This means that the function will be executed again to solve for these two numbers, since none of these numbers are known yet, it will continue calling this function until the base case is reached. In mathematical terms, the Fibonacci sequence is based on a formula that is based on the first and second terms. In math class you have probably learned about such recursive sequences, the value of the next term depends on the current term or terms.\n\n\nPractice problems\n\n\n\n\nCCC '13 S3 - Chances of Winning\n\n\nVM7WC '16 #4 Silver - Tests or Test Cases?\n\n\nCCC '96 S3 - Pattern Generator\n\n\nCCC '03 S3 - Floor Plan\n *\nincludes graph theory",
            "title": "Recursion"
        },
        {
            "location": "/recursion/#recursion",
            "text": "Recursion is a fundamental concept that is incredibly useful in competitive programming. It is commonly used to solve problems in graph theory and implemented in algorithms such as  depth and beadth first search . Recursion also provides a very simple and straightforward way of thinking about  dynamic programming . Recursion is very powerful and necessary for many problems.  The idea with recursion is that a function will be called, but in order to return a value it relies on the same function being called. It will continue to \u201cwait\u201d until a base case is reached, where afterwards all of the other functions can return values.",
            "title": "Recursion"
        },
        {
            "location": "/recursion/#example",
            "text": "A common example is a recursive solution to finding the  n th Fibonacci number  fib ( n )   { \n     if   ( n   ==   0   ||   n   ==   1 ) \n         return   1 \n     return   fib ( n - 1 )   +   fib ( n - 2 )  }",
            "title": "Example"
        },
        {
            "location": "/recursion/#explanation",
            "text": "This function begins with the parameter  n , the answer in the first call of the function depends on the previous two Fibonacci numbers since  fib(n) = fib(n-1) + fib(n-2) . This means that the function will be executed again to solve for these two numbers, since none of these numbers are known yet, it will continue calling this function until the base case is reached. In mathematical terms, the Fibonacci sequence is based on a formula that is based on the first and second terms. In math class you have probably learned about such recursive sequences, the value of the next term depends on the current term or terms.",
            "title": "Explanation"
        },
        {
            "location": "/recursion/#practice-problems",
            "text": "CCC '13 S3 - Chances of Winning  VM7WC '16 #4 Silver - Tests or Test Cases?  CCC '96 S3 - Pattern Generator  CCC '03 S3 - Floor Plan  * includes graph theory",
            "title": "Practice problems"
        },
        {
            "location": "/dp/",
            "text": "Dynamic Programming\n\n\nDynamic Programming is a very important topic in competitive programming, showing up often on contests. Dynamic Programming simply means the use of \nsubproblems\n in order to solve a larger problem. This involves calculating and storing the result of the correct answer for a certain subproblem and reusing it when combined with other subproblems.\n\n\nImplementation\n\n\nA simple example of the effectiveness of DP is when computing the \nn\nth Fibonacci number.\n\n\nRecursive approach\n\n\nA naive recursive solution would need to calculate \nfib(x)\n every single time \nfib(x)\n is called for every number \nx\n, making the approach extremely slow when \nn\n is large.\n\n\nfib\n(\nn\n)\n \n{\n\n\nif\n \n(\nn\n \n==\n \n0\n \n||\n \nn\n \n==\n \n1\n)\n\n    \nreturn\n \n1\n\n\nreturn\n \nfib\n(\nn\n-\n1\n)\n \n+\n \nfib\n(\nn\n-\n2\n)\n \n// We are calculating fib(n-2) every time\n\n\n\n\n\n\nDP approach\n\n\nA solution using dynamic programming just stores the results of the Fibonacci numbers after being computed, treating \nfib(n-1)\n as the subproblem.\n\n\nmemo\n \n=\n \n{}\n \n//dictionary, map or array\n\n\n\nfib\n(\nn\n)\n \n{\n\n\nif\n \n(\nmemo\n[\nn\n]\n \n!=\n \n-\n1\n)\n \n// It has already been calculateed\n\n    \nreturn\n \nmemo\n[\nn\n]\n\n\nif\n \n(\nn\n \n==\n \n0\n \n||\n \nn\n \n==\n \n1\n)\n\n    \nreturn\n \n1\n\n\ntoReturn\n \n=\n \nfib\n(\nn\n-\n1\n)\n \n+\n \nfib\n(\nn\n-\n2\n)\n\n\nmemo\n[\nn\n]\n \n=\n \ntoReturn\n \n//After calculating the result, store it for later use\n\n\nreturn\n \ntoReturn\n\n\n\n\n\n\nThis solution now ensures that you no longer need to recalculate results that you have already made, saving a lot of time when solving multiple queries.\n\n\nIn dynamic programming, the subproblems often involve finding the solution for a prefix, suffix or subset of an array or set of numbers.\n\n\nResources\n\n\nGreat resources for learning dynamic programming by MIT Open Courseware:\n- \nDynamic Programming I\n\n- \nDynamic Programming II\n\n- \nDynamic Programming III\n\n\nMore advanced concepts with bitmasking\n- \nHackerEarth DP Bitmasking",
            "title": "Dynamic Programming"
        },
        {
            "location": "/dp/#dynamic-programming",
            "text": "Dynamic Programming is a very important topic in competitive programming, showing up often on contests. Dynamic Programming simply means the use of  subproblems  in order to solve a larger problem. This involves calculating and storing the result of the correct answer for a certain subproblem and reusing it when combined with other subproblems.",
            "title": "Dynamic Programming"
        },
        {
            "location": "/dp/#implementation",
            "text": "A simple example of the effectiveness of DP is when computing the  n th Fibonacci number.",
            "title": "Implementation"
        },
        {
            "location": "/dp/#recursive-approach",
            "text": "A naive recursive solution would need to calculate  fib(x)  every single time  fib(x)  is called for every number  x , making the approach extremely slow when  n  is large.  fib ( n )   {  if   ( n   ==   0   ||   n   ==   1 ) \n     return   1  return   fib ( n - 1 )   +   fib ( n - 2 )   // We are calculating fib(n-2) every time",
            "title": "Recursive approach"
        },
        {
            "location": "/dp/#dp-approach",
            "text": "A solution using dynamic programming just stores the results of the Fibonacci numbers after being computed, treating  fib(n-1)  as the subproblem.  memo   =   {}   //dictionary, map or array  fib ( n )   {  if   ( memo [ n ]   !=   - 1 )   // It has already been calculateed \n     return   memo [ n ]  if   ( n   ==   0   ||   n   ==   1 ) \n     return   1  toReturn   =   fib ( n - 1 )   +   fib ( n - 2 )  memo [ n ]   =   toReturn   //After calculating the result, store it for later use  return   toReturn   This solution now ensures that you no longer need to recalculate results that you have already made, saving a lot of time when solving multiple queries.  In dynamic programming, the subproblems often involve finding the solution for a prefix, suffix or subset of an array or set of numbers.",
            "title": "DP approach"
        },
        {
            "location": "/dp/#resources",
            "text": "Great resources for learning dynamic programming by MIT Open Courseware:\n-  Dynamic Programming I \n-  Dynamic Programming II \n-  Dynamic Programming III  More advanced concepts with bitmasking\n-  HackerEarth DP Bitmasking",
            "title": "Resources"
        },
        {
            "location": "/graph/",
            "text": "Graph Theory\n\n\nGraph theory is a topic that shows up commonly in competitive programming. \n\n\nA graph is a sort of map. You can imagine many nodes (houses, cities, other objects) which are interconnected by edges (roads). Graph theory aims to answer questions about the paths between these nodes.\n\n\nGraph Traversal\n\n\nBreadth First Search and Depth First Search are methods of traversing a graph that can be used to gather information such as if a specific node exists or to find a valid path to that node. \n\n\nBreadth First Search\n\n\nBFS visits all nodes one \u201clayer\u201d at a time. Starting at the root it looks at all child nodes of the root. Afterwards, for each of these children, it will perform the same action, it will check all the children of the children of the root. It is easier to understand with a picture:\n\n\n\n\nJava implmentation\n\n\nThe following is an example in Java of how to implement BFS. This is the solution to \nVM7WC '16 #3 Silver - Can Shahir even get there?!\n\n. After reaching a node, it adds all of its children and moves to the next node in the queue. This ensures that each layer will be opened one by one.\n\n\nimport\n \njava.util.*\n;\n\n\n\npublic\n \nclass\n \nMain\n \n{\n\n\n  \npublic\n \nstatic\n \nArrayList\n<\nArrayList\n<\nInteger\n>>\n \ngraph\n \n=\n \nnew\n \nArrayList\n<\nArrayList\n<\nInteger\n>>();\n\n\n  \nstatic\n \nScanner\n \nscan\n \n=\n \nnew\n \nScanner\n(\nSystem\n.\nin\n);\n\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \nint\n \nn\n,\n \nm\n,\n \na\n,\n \nb\n;\n\n    \nn\n \n=\n \nscan\n.\nnextInt\n();\n\n    \nm\n \n=\n \nscan\n.\nnextInt\n();\n\n    \na\n \n=\n \nscan\n.\nnextInt\n();\n\n    \nb\n \n=\n \nscan\n.\nnextInt\n();\n\n\n    \n//Creating a graph using adjacency lists\n\n    \n//In this case the houses (nodes) are numbers, so you can just use arraylists/arrays\n\n    \n//If the nodes are strings, you pretty much have to use a HashMap\n\n\n    \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<=\n \nn\n;\n \ni\n \n++)\n \n{\n \n//Creating new arraylists for each possible node (n nodes)\n\n      \ngraph\n.\nadd\n(\nnew\n \nArrayList\n<\nInteger\n>());\n\n    \n}\n\n\n    \nint\n \nx\n,\n \ny\n;\n\n\n    \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nm\n;\n \ni\n \n++)\n \n{\n\n      \nx\n \n=\n \nscan\n.\nnextInt\n();\n\n      \ny\n \n=\n \nscan\n.\nnextInt\n();\n\n      \ngraph\n.\nget\n(\nx\n).\nadd\n(\ny\n);\n \n//adds the adjacent node (neighbor) to the graph\n\n      \ngraph\n.\nget\n(\ny\n).\nadd\n(\nx\n);\n \n//adds the connection the other way\n\n      \n//Means that x will be connnected to y and y will be connceted to x\n\n    \n}\n\n\n    \nif\n \n(\nBFS\n(\na\n,\nb\n))\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"GO SHAHIR!\"\n);\n\n    \nelse\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"NO SHAHIR!\"\n);\n\n  \n}\n\n\n  \n//BFS will start at the start node, and check all the nodes beside it\n\n  \n//It adds those nodes to the queue, and then spreads out again\n\n  \n// Keeps expanding one \"layer\" at a time until the target is seen or until there's nothing left to check\n\n  \npublic\n \nstatic\n \nboolean\n \nBFS\n(\nint\n \nstart\n,\n \nint\n \nend\n)\n \n{\n\n    \nArrayDeque\n<\nArrayList\n<\nInteger\n>>\n \nqueue\n \n=\n \nnew\n \nArrayDeque\n<>();\n \n//Double ended queue, similar functions as arraylist, faster pop from front though\n\n    \nHashSet\n<\nInteger\n>\n \nvisited\n \n=\n \nnew\n \nHashSet\n<>();\n \n//stores visited nodes\n\n    \nArrayList\n<\nInteger\n>\n \ntemp\n \n=\n \nnew\n \nArrayList\n<\nInteger\n>();\n\n    \ntemp\n.\nadd\n(\nstart\n);\n \n//Creates a temporary \"path\" containing only the start node\n\n    \nqueue\n.\nadd\n(\ntemp\n);\n\n\n    \nwhile\n(\nqueue\n.\nsize\n()\n \n!=\n \n0\n){\n \n//If the queue is not empty\n\n        \nArrayList\n<\nInteger\n>\n \npath\n \n=\n \nqueue\n.\npoll\n();\n \n//Gets the first path in the queue\n\n        \nint\n \nnode\n \n=\n \npath\n.\nget\n(\npath\n.\nsize\n()-\n1\n);\n \n//Gets the last node in the path\n\n\n        \nif\n \n(\nnode\n \n==\n \nend\n)\n \n{\n \n//If you've found the target\n\n          \nreturn\n \ntrue\n;\n\n        \n}\n\n\n        \nif\n(!\nvisited\n.\ncontains\n(\nnode\n)){\n \n//If vertex hasn't already been visited\n\n            \nfor\n \n(\nint\n \nadj\n:\n \ngraph\n.\nget\n(\nnode\n))\n \n{\n \n//Checks all neighbor nodes\n\n              \nArrayList\n<\nInteger\n>\n \nnewpath\n \n=\n \nnew\n \nArrayList\n<\nInteger\n>(\npath\n);\n \n//Copies the current path IMPORTANT TO DO THIS CONSTUCTOR COPY OR IT WILL POINT TO SAME MEMORY\n\n              \nnewpath\n.\nadd\n(\nadj\n);\n \n//Adds the neighboring node to the path\n\n              \nqueue\n.\nadd\n(\nnewpath\n);\n \n//Adds the new path into the queue\n\n            \n}\n\n            \nvisited\n.\nadd\n(\nnode\n);\n \n//Adds the node to visited\n\n        \n}\n\n    \n}\n\n\n    \nreturn\n \nfalse\n;\n \n//Queue is empty, all nodes have been checked, no possible path\n\n  \n}\n\n\n}\n\n\n\n\n\n\nDepth First Search\n\n\nDFS continues visiting the first (or leftmost) child of each node until there are no more nodes. Afterwards, it returns to the parent of the last node in the path, and visits the rest of it\u2019s children. It goes as deep as possible down each path, and then moves up one layer and checks as deep as possible again. It is easier to understand with a picture.\n\n\n\n\nDepth first search can be written iteratively by changing one line of iterative breadth first search.\n\n\n\n\nHint: you can then switch the deque to a simple vector\n\n\n\n\nDFS can also be written recursively.\n\n\nDFS\n(\nstart\n,\nend\n,\npath\n)\n \n{\n\n    \n// In python recursion you must copy the path since it passes by reference\n\n    \n// otherwise it will be passed a copy in C++ and Java\n\n    \npath\n \n=\n \npath\n \n+\n \n[\nstart\n]\n \n// Python\n\n    \npath\n.\npush\n(\nstart\n)\n \n// Other languages\n\n    \nif\n \n(\nstart\n \n==\n \nend\n)\n\n        \nreturn\n \npath\n\n    \nif\n \n(\ngraph\n[\nstart\n].\nsize\n \n==\n \n0\n)\n \n// Reached the end of a path (a leaf)\n\n        \nreturn\n \n[]\n \n// No path possible\n\n    \nfor\n \neach\n \nnode\n \nin\n \ngraph\n[\nstart\n]\n \n{\n \n// For-each loop through all children of the current node\n\n        \nif\n \n(\nnode\n \nnot\n \nin\n \npath\n)\n \n{\n \n// Do not go backwards in the path\n\n            \nnewpath\n \n=\n \nDFS\n(\nnode\n,\nend\n,\npath\n)\n\n            \nif\n \nnewpath\n \n!=\n \n[]\n \n// If a path to the end if found\n\n                \nreturn\n \nnewpath\n\n    \nreturn\n \n[]\n \n// If nothing is found return nothing\n\n\n}\n\n\n\n\n\n\nDijkstra's Algorithm\n\n\nIn many cases, you are trying to find the shortest path from a single source to a destination given that each edge between nodes have different lengths or \nweights\n. This common problem, often known as finding the \nSingle Source Shortest Path\n, can be solved using Dijkstra's algorithm.\n\n\nMIT OpenCourseware\n\n\nWatch this, then try \nSingle Source Shortest Path\n.\n\n\n\nImplementation\n\n\nBelow is a partial Python solution to \nSingle Source Shortest Path\n using Dijkstra's.\n\n\ndef\n \ndijkstras\n(\nGraph\n,\n \nweights\n,\n \nsource\n):\n\n    \ndistances\n \n=\n \n{}\n\n    \nfor\n \ni\n \nin\n \nGraph\n:\n\n        \ndistances\n[\ni\n]\n \n=\n \ninf\n\n    \nq\n,\n \nvisited\n \n=\n \n[(\n0\n,\n \nsource\n)],\n \nset\n()\n \n    \ndistances\n[\nsource\n]\n \n=\n \n0\n\n    \nwhile\n \nq\n:\n\n        \n(\ndist\n,\n \nv1\n)\n \n=\n \nheappop\n(\nq\n)\n\n        \nif\n \nv1\n \nin\n \nvisited\n:\n\n            \ncontinue\n\n        \nvisited\n.\nadd\n(\nv1\n)\n\n        \nfor\n \nv2\n \nin\n \nGraph\n[\nv1\n]:\n\n            \nif\n \nv2\n \nnot\n \nin\n \nvisited\n:\n\n                \nnewd\n \n=\n \ndist\n \n+\n \nweights\n[(\nv1\n,\n \nv2\n)]\n \n                \nheappush\n(\nq\n,\n \n(\ndist\n \n+\n \nweights\n[(\nv1\n,\n \nv2\n)],\n \nv2\n))\n\n            \nif\n \ndistances\n[\nv2\n]\n \n>\n \nnewd\n:\n\n                \ndistances\n[\nv2\n]\n \n=\n \nnewd\n\n  \nreturn\n \ndistances\n\n\n\n\n\n\nPractice Problems\n\n\n\n\nVM7WC '16 #3 Silver - Can Shahir even get there?!\n\n\nCCC '01 S3 - Strategic Bombing\n\n\nCCC '13 S4 - Who is Taller?\n\n\nCCC '10 J5 - Knight Hop\n\n\nPursuit of Knowledge",
            "title": "Graph Theory"
        },
        {
            "location": "/graph/#graph-theory",
            "text": "Graph theory is a topic that shows up commonly in competitive programming.   A graph is a sort of map. You can imagine many nodes (houses, cities, other objects) which are interconnected by edges (roads). Graph theory aims to answer questions about the paths between these nodes.",
            "title": "Graph Theory"
        },
        {
            "location": "/graph/#graph-traversal",
            "text": "Breadth First Search and Depth First Search are methods of traversing a graph that can be used to gather information such as if a specific node exists or to find a valid path to that node.",
            "title": "Graph Traversal"
        },
        {
            "location": "/graph/#breadth-first-search",
            "text": "BFS visits all nodes one \u201clayer\u201d at a time. Starting at the root it looks at all child nodes of the root. Afterwards, for each of these children, it will perform the same action, it will check all the children of the children of the root. It is easier to understand with a picture:",
            "title": "Breadth First Search"
        },
        {
            "location": "/graph/#java-implmentation",
            "text": "The following is an example in Java of how to implement BFS. This is the solution to  VM7WC '16 #3 Silver - Can Shahir even get there?! . After reaching a node, it adds all of its children and moves to the next node in the queue. This ensures that each layer will be opened one by one.  import   java.util.* ;  public   class   Main   { \n\n   public   static   ArrayList < ArrayList < Integer >>   graph   =   new   ArrayList < ArrayList < Integer >>(); \n\n   static   Scanner   scan   =   new   Scanner ( System . in ); \n\n   public   static   void   main ( String []   args )   { \n     int   n ,   m ,   a ,   b ; \n     n   =   scan . nextInt (); \n     m   =   scan . nextInt (); \n     a   =   scan . nextInt (); \n     b   =   scan . nextInt (); \n\n     //Creating a graph using adjacency lists \n     //In this case the houses (nodes) are numbers, so you can just use arraylists/arrays \n     //If the nodes are strings, you pretty much have to use a HashMap \n\n     for   ( int   i   =   0 ;   i   <=   n ;   i   ++)   {   //Creating new arraylists for each possible node (n nodes) \n       graph . add ( new   ArrayList < Integer >()); \n     } \n\n     int   x ,   y ; \n\n     for   ( int   i   =   0 ;   i   <   m ;   i   ++)   { \n       x   =   scan . nextInt (); \n       y   =   scan . nextInt (); \n       graph . get ( x ). add ( y );   //adds the adjacent node (neighbor) to the graph \n       graph . get ( y ). add ( x );   //adds the connection the other way \n       //Means that x will be connnected to y and y will be connceted to x \n     } \n\n     if   ( BFS ( a , b )) \n       System . out . println ( \"GO SHAHIR!\" ); \n     else \n       System . out . println ( \"NO SHAHIR!\" ); \n   } \n\n   //BFS will start at the start node, and check all the nodes beside it \n   //It adds those nodes to the queue, and then spreads out again \n   // Keeps expanding one \"layer\" at a time until the target is seen or until there's nothing left to check \n   public   static   boolean   BFS ( int   start ,   int   end )   { \n     ArrayDeque < ArrayList < Integer >>   queue   =   new   ArrayDeque <>();   //Double ended queue, similar functions as arraylist, faster pop from front though \n     HashSet < Integer >   visited   =   new   HashSet <>();   //stores visited nodes \n     ArrayList < Integer >   temp   =   new   ArrayList < Integer >(); \n     temp . add ( start );   //Creates a temporary \"path\" containing only the start node \n     queue . add ( temp ); \n\n     while ( queue . size ()   !=   0 ){   //If the queue is not empty \n         ArrayList < Integer >   path   =   queue . poll ();   //Gets the first path in the queue \n         int   node   =   path . get ( path . size ()- 1 );   //Gets the last node in the path \n\n         if   ( node   ==   end )   {   //If you've found the target \n           return   true ; \n         } \n\n         if (! visited . contains ( node )){   //If vertex hasn't already been visited \n             for   ( int   adj :   graph . get ( node ))   {   //Checks all neighbor nodes \n               ArrayList < Integer >   newpath   =   new   ArrayList < Integer >( path );   //Copies the current path IMPORTANT TO DO THIS CONSTUCTOR COPY OR IT WILL POINT TO SAME MEMORY \n               newpath . add ( adj );   //Adds the neighboring node to the path \n               queue . add ( newpath );   //Adds the new path into the queue \n             } \n             visited . add ( node );   //Adds the node to visited \n         } \n     } \n\n     return   false ;   //Queue is empty, all nodes have been checked, no possible path \n   }  }",
            "title": "Java implmentation"
        },
        {
            "location": "/graph/#depth-first-search",
            "text": "DFS continues visiting the first (or leftmost) child of each node until there are no more nodes. Afterwards, it returns to the parent of the last node in the path, and visits the rest of it\u2019s children. It goes as deep as possible down each path, and then moves up one layer and checks as deep as possible again. It is easier to understand with a picture.   Depth first search can be written iteratively by changing one line of iterative breadth first search.   Hint: you can then switch the deque to a simple vector   DFS can also be written recursively.  DFS ( start , end , path )   { \n     // In python recursion you must copy the path since it passes by reference \n     // otherwise it will be passed a copy in C++ and Java \n     path   =   path   +   [ start ]   // Python \n     path . push ( start )   // Other languages \n     if   ( start   ==   end ) \n         return   path \n     if   ( graph [ start ]. size   ==   0 )   // Reached the end of a path (a leaf) \n         return   []   // No path possible \n     for   each   node   in   graph [ start ]   {   // For-each loop through all children of the current node \n         if   ( node   not   in   path )   {   // Do not go backwards in the path \n             newpath   =   DFS ( node , end , path ) \n             if   newpath   !=   []   // If a path to the end if found \n                 return   newpath \n     return   []   // If nothing is found return nothing  }",
            "title": "Depth First Search"
        },
        {
            "location": "/graph/#dijkstras-algorithm",
            "text": "In many cases, you are trying to find the shortest path from a single source to a destination given that each edge between nodes have different lengths or  weights . This common problem, often known as finding the  Single Source Shortest Path , can be solved using Dijkstra's algorithm.",
            "title": "Dijkstra's Algorithm"
        },
        {
            "location": "/graph/#mit-opencourseware",
            "text": "Watch this, then try  Single Source Shortest Path .",
            "title": "MIT OpenCourseware"
        },
        {
            "location": "/graph/#implementation",
            "text": "Below is a partial Python solution to  Single Source Shortest Path  using Dijkstra's.  def   dijkstras ( Graph ,   weights ,   source ): \n     distances   =   {} \n     for   i   in   Graph : \n         distances [ i ]   =   inf \n     q ,   visited   =   [( 0 ,   source )],   set ()  \n     distances [ source ]   =   0 \n     while   q : \n         ( dist ,   v1 )   =   heappop ( q ) \n         if   v1   in   visited : \n             continue \n         visited . add ( v1 ) \n         for   v2   in   Graph [ v1 ]: \n             if   v2   not   in   visited : \n                 newd   =   dist   +   weights [( v1 ,   v2 )]  \n                 heappush ( q ,   ( dist   +   weights [( v1 ,   v2 )],   v2 )) \n             if   distances [ v2 ]   >   newd : \n                 distances [ v2 ]   =   newd \n   return   distances",
            "title": "Implementation"
        },
        {
            "location": "/graph/#practice-problems",
            "text": "VM7WC '16 #3 Silver - Can Shahir even get there?!  CCC '01 S3 - Strategic Bombing  CCC '13 S4 - Who is Taller?  CCC '10 J5 - Knight Hop  Pursuit of Knowledge",
            "title": "Practice Problems"
        },
        {
            "location": "/adhoc/",
            "text": "Ad Hoc\n\n\n\n\nAd hoc problems are those whose algorithms do not fall into standard categories with well-studied solutions. Each ad hoc problem is different meaning there is no specific or general techniques that exist to solve them. These problems may require novel observations and optimizations to get the solution to run within the given time.\n\n\nCase Study\n\n\nTo demonstrate, we will solve this \nAd Hoc Example Problem\n.\n\n\nSolution\n\n\nThe input can first be sorted in \nO(n log n)\n time.\nNext, we must precompute all powers of \n2\n from \n2\n to \nn-2\n. This can be found in \nO(n)\n time with dynamic programming.\n\n\nWe will solve this problem using \ntelescoping series\n. The question is really asking us to find the maximum and the minimum element of every possible subset of elements (of which there exists \n2^n\n). \n\n\nObservation 1\n\n\nIt is important to note that for each pair of elements \na[i]\n and \na[j]\n in the (sorted) array, there are \n2^(j-i-1)\n subsets in which \na[i]\n is the minimum value and \na[j]\n is the maximum value.\n\n\nTherefore, the answer can be written as the sum of \n2^(j-i-1) * (a[j]-a[i])\n for all \nj > i\n.\nThis can be computed in \nO(n^2)\n time by iterating through all possible pairs \n(i,j)\n; however, given the constraint \nn <= 300 000\n, this algorithm will not run within the 2 second time limit.\n\n\nObservation 2\n\n\nOur solution must be optimized. Let\u2019s write out the first few terms of this relation:\nWhen \nj-i-1 = 0\n, you add to the total:\n\n\n2^0 * (a[1]-a[0]) + 2^0 * (a[2] - a[1]) + ... + 2^0 * (a[n-1] - a[n-2])\n= 2^0 * (a[1] - a[0] + a[2] - a[1] + ... + a[n-2] - a[n-3] + a[n-1] - a[n-2])\n= 2^0 * (a[n-1] - a[0]) (the first and last elements of the array)\n\n\n\n\n\nWhen \nj-i-1 = 1\n, you add to the total:\n\n\n2^1 * (a[2] - a[0] + a[3] - a[1] + ... +  a[n-2] - a[n-4] + a[n-1] - a[n-3])\n= 2^1 * (a[n-1]+a[n-2] - a[0] - a[1]) (the first two and last two elements of the array)\n\n\n\n\n\nThe key to this problem is noticing that the pattern continues until \nj-i-1 = n-2\n.\n\n\nConclusion\n\n\nThus:\n\n\nlet pre[i] be prefix sum of the array up to i\nlet suf[i] be suffix sum of the array from i onwards\n\n\n\n\n\nThe relation can be generalized to:\nThe answer is the sum from \ni=0\n to \ni=n-2\n of \n(2^i) * (suf[n-1-i]-pre[i])\n\n\nThis can be computed in \nO(n)\n time giving a final time complexity of \nO(nlogn + n + n)\n = \nO(nlogn)\n which will run within the time constraints.\n\n\nC++ Implementation\n\n\n#define MOD 1000000007\n\n\n#define ll long long int\n\n\n#include\n \n<bits/stdc++.h>\n\n\n\nusing\n \nnamespace\n \nstd\n;\n\n\n\nll\n \ncomp\n[\n300002\n];\n\n\nll\n \npre\n[\n300002\n];\n\n\nll\n \nsuf\n[\n300002\n];\n\n\nll\n \npow2\n[\n300002\n]\n \n=\n \n{\n1\n};\n\n\nll\n \nn\n;\n\n\n\nint\n \nmain\n()\n \n{\n\n\n    \nll\n \nrunsum\n \n=\n \n0\n;\n\n    \nscanf\n(\n\"%i\"\n,\n \n&\nn\n);\n\n    \nfor\n \n(\nll\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n;\n \ni\n++\n)\n \n{\n\n      \ncin\n \n>>\n \ncomp\n[\ni\n];\n\n    \n}\n\n\n    \nfor\n \n(\nll\n \ni\n \n=\n \n1\n;\n \ni\n \n<\n \nn\n;\n \ni\n++\n)\n \n{\n\n      \npow2\n[\ni\n]\n \n=\n \n(\npow2\n[\ni\n-\n1\n]\n \n*\n \n2\n)\n \n%\n \nMOD\n;\n\n    \n}\n\n\n    \nsort\n(\ncomp\n,\n \ncomp\n+\nn\n);\n\n\n    \npre\n[\n0\n]\n \n=\n \ncomp\n[\n0\n]\n \n%\n \nMOD\n;\n\n    \nsuf\n[\nn\n-\n1\n]\n \n=\n \ncomp\n[\nn\n-\n1\n]\n \n%\n \nMOD\n;\n\n    \nfor\n \n(\nll\n \ni\n \n=\n \n1\n;\n \ni\n \n<\n \nn\n;\n \ni\n++\n)\n \n{\n\n      \npre\n[\ni\n]\n \n=\n \n(\npre\n[\ni\n-\n1\n]\n \n+\n \ncomp\n[\ni\n])\n \n%\n \nMOD\n;\n\n      \nsuf\n[\nn\n-\n1\n-\ni\n]\n \n=\n \n(\nsuf\n[\nn\n-\ni\n]\n \n+\n \ncomp\n[\nn\n-\n1\n-\ni\n])\n \n%\n \nMOD\n;\n\n    \n}\n\n\n    \nfor\n \n(\nll\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n-\n1\n;\n \ni\n++\n)\n \n{\n\n      \nrunsum\n \n+=\n \n(\npow2\n[\ni\n]\n \n*\n \n(\nsuf\n[\nn\n-\ni\n-\n1\n]\n-\npre\n[\ni\n]\n+\nMOD\n)\n%\nMOD\n)\n \n%\n \nMOD\n;\n\n      \nrunsum\n \n%=\n \nMOD\n;\n\n    \n}\n\n    \ncout\n \n<<\n \nrunsum\n \n%\n \nMOD\n;\n\n    \nreturn\n \n0\n;\n\n\n}",
            "title": "Ad Hoc"
        },
        {
            "location": "/adhoc/#ad-hoc",
            "text": "Ad hoc problems are those whose algorithms do not fall into standard categories with well-studied solutions. Each ad hoc problem is different meaning there is no specific or general techniques that exist to solve them. These problems may require novel observations and optimizations to get the solution to run within the given time.",
            "title": "Ad Hoc"
        },
        {
            "location": "/adhoc/#case-study",
            "text": "To demonstrate, we will solve this  Ad Hoc Example Problem .",
            "title": "Case Study"
        },
        {
            "location": "/adhoc/#solution",
            "text": "The input can first be sorted in  O(n log n)  time.\nNext, we must precompute all powers of  2  from  2  to  n-2 . This can be found in  O(n)  time with dynamic programming.  We will solve this problem using  telescoping series . The question is really asking us to find the maximum and the minimum element of every possible subset of elements (of which there exists  2^n ).",
            "title": "Solution"
        },
        {
            "location": "/adhoc/#observation-1",
            "text": "It is important to note that for each pair of elements  a[i]  and  a[j]  in the (sorted) array, there are  2^(j-i-1)  subsets in which  a[i]  is the minimum value and  a[j]  is the maximum value.  Therefore, the answer can be written as the sum of  2^(j-i-1) * (a[j]-a[i])  for all  j > i .\nThis can be computed in  O(n^2)  time by iterating through all possible pairs  (i,j) ; however, given the constraint  n <= 300 000 , this algorithm will not run within the 2 second time limit.",
            "title": "Observation 1"
        },
        {
            "location": "/adhoc/#observation-2",
            "text": "Our solution must be optimized. Let\u2019s write out the first few terms of this relation:\nWhen  j-i-1 = 0 , you add to the total:  2^0 * (a[1]-a[0]) + 2^0 * (a[2] - a[1]) + ... + 2^0 * (a[n-1] - a[n-2])\n= 2^0 * (a[1] - a[0] + a[2] - a[1] + ... + a[n-2] - a[n-3] + a[n-1] - a[n-2])\n= 2^0 * (a[n-1] - a[0]) (the first and last elements of the array)  When  j-i-1 = 1 , you add to the total:  2^1 * (a[2] - a[0] + a[3] - a[1] + ... +  a[n-2] - a[n-4] + a[n-1] - a[n-3])\n= 2^1 * (a[n-1]+a[n-2] - a[0] - a[1]) (the first two and last two elements of the array)  The key to this problem is noticing that the pattern continues until  j-i-1 = n-2 .",
            "title": "Observation 2"
        },
        {
            "location": "/adhoc/#conclusion",
            "text": "Thus:  let pre[i] be prefix sum of the array up to i\nlet suf[i] be suffix sum of the array from i onwards  The relation can be generalized to:\nThe answer is the sum from  i=0  to  i=n-2  of  (2^i) * (suf[n-1-i]-pre[i])  This can be computed in  O(n)  time giving a final time complexity of  O(nlogn + n + n)  =  O(nlogn)  which will run within the time constraints.",
            "title": "Conclusion"
        },
        {
            "location": "/adhoc/#c-implementation",
            "text": "#define MOD 1000000007  #define ll long long int  #include   <bits/stdc++.h>  using   namespace   std ;  ll   comp [ 300002 ];  ll   pre [ 300002 ];  ll   suf [ 300002 ];  ll   pow2 [ 300002 ]   =   { 1 };  ll   n ;  int   main ()   { \n\n     ll   runsum   =   0 ; \n     scanf ( \"%i\" ,   & n ); \n     for   ( ll   i   =   0 ;   i   <   n ;   i ++ )   { \n       cin   >>   comp [ i ]; \n     } \n\n     for   ( ll   i   =   1 ;   i   <   n ;   i ++ )   { \n       pow2 [ i ]   =   ( pow2 [ i - 1 ]   *   2 )   %   MOD ; \n     } \n\n     sort ( comp ,   comp + n ); \n\n     pre [ 0 ]   =   comp [ 0 ]   %   MOD ; \n     suf [ n - 1 ]   =   comp [ n - 1 ]   %   MOD ; \n     for   ( ll   i   =   1 ;   i   <   n ;   i ++ )   { \n       pre [ i ]   =   ( pre [ i - 1 ]   +   comp [ i ])   %   MOD ; \n       suf [ n - 1 - i ]   =   ( suf [ n - i ]   +   comp [ n - 1 - i ])   %   MOD ; \n     } \n\n     for   ( ll   i   =   0 ;   i   <   n - 1 ;   i ++ )   { \n       runsum   +=   ( pow2 [ i ]   *   ( suf [ n - i - 1 ] - pre [ i ] + MOD ) % MOD )   %   MOD ; \n       runsum   %=   MOD ; \n     } \n     cout   <<   runsum   %   MOD ; \n     return   0 ;  }",
            "title": "C++ Implementation"
        },
        {
            "location": "/stl/",
            "text": "STL Containers\n\n\nBoth Java and C++ have large standard libraries with many amazing containers and functions. It is important to know your language because it can save you a lot of time coding.\n\n\nComplexity Specifications\n\n\n\n\n\n\n\n\nC++\n\n\nJava\n\n\nInsertion\n\n\nDelete\n\n\nAccess\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nvector\n\n\nArrayList\n\n\nO(1)\n back, \nO(N)\n otherwise\n\n\nO(1)\n back \nO(N)\n otherwise\n\n\nO(1)\n\n\nResizable array\n\n\n\n\n\n\nset\n\n\nSortedSet\n\n\nO(logn)\n\n\nO(logn)\n\n\nO(logn)\n\n\nMaintains sorted order, implemented as BST\n\n\n\n\n\n\nunordered_set\n\n\nHashSet\n\n\nO(1)\n\n\nO(1)\n\n\nIt is average case \nO(1)\n to check if a set contains an element\n\n\n\n\n\n\n\n\ndeque\n\n\nDeque\n\n\nO(1)\n front or back \nO(N)\n otherwise\n\n\nO(1)\n front or back \nO(N)\n otherwise\n\n\nO(1)\n\n\nDouble ended queue\n\n\n\n\n\n\nlist\n\n\nList\n\n\nO(1)\n anywhere\n\n\nO(1)\n anywhere\n\n\nO(N)\n to get iterator\n\n\n\n\n\n\n\n\nunordered_map\n\n\nHashMap\n\n\nO(1)\n\n\nO(1)\n\n\nO(1)\n access It is average case \nO(1)\n to check if a HashMap contains a key\n\n\nSorted alternatives are \nstd::map\n and \nSortedMap\n, worse complexity",
            "title": "STL Containers"
        },
        {
            "location": "/stl/#stl-containers",
            "text": "Both Java and C++ have large standard libraries with many amazing containers and functions. It is important to know your language because it can save you a lot of time coding.",
            "title": "STL Containers"
        },
        {
            "location": "/stl/#complexity-specifications",
            "text": "C++  Java  Insertion  Delete  Access  Notes      vector  ArrayList  O(1)  back,  O(N)  otherwise  O(1)  back  O(N)  otherwise  O(1)  Resizable array    set  SortedSet  O(logn)  O(logn)  O(logn)  Maintains sorted order, implemented as BST    unordered_set  HashSet  O(1)  O(1)  It is average case  O(1)  to check if a set contains an element     deque  Deque  O(1)  front or back  O(N)  otherwise  O(1)  front or back  O(N)  otherwise  O(1)  Double ended queue    list  List  O(1)  anywhere  O(1)  anywhere  O(N)  to get iterator     unordered_map  HashMap  O(1)  O(1)  O(1)  access It is average case  O(1)  to check if a HashMap contains a key  Sorted alternatives are  std::map  and  SortedMap , worse complexity",
            "title": "Complexity Specifications"
        },
        {
            "location": "/solutions/",
            "text": "Problem Solutions Archive\n\n\nHere are a set of solutions to some common problems found on competitive programming sites. Please only use these if you are stuck on a problem after you've tried it, or for learning/reference. \nDon't copy paste solutions.\n\n\nDMOJ\n\n\n\n\n\n\n\n\nProblem\n\n\nSource\n\n\nLanguage\n\n\nDifficulty\n\n\n\n\n\n\n\n\n\n\n\n\nanoisyclass\n\n\nSource\n\n\nPY3\n\n\n8.0\n\n\n\n\n\n\n\n\naplusb\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nbf1\n\n\nSource\n\n\nPY3\n\n\n4.0\n\n\n\n\n\n\n\n\nbf1hard\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nbf2\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nbf3\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nbf3hard\n\n\nSource\n\n\nC\n\n\n15.0\n\n\n\n\n\n\n\n\nbinary\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nboolean\n\n\nSource\n\n\nPY3\n\n\n4.0\n\n\n\n\n\n\n\n\nbts16p1\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nbts16p2\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nbts16p3\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\nccc00j2\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nccc00j3\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc00j4\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\nccc00s4\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\nccc01j2\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nccc01s3\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\nccc01s5\n\n\nSource\n\n\nPY2\n\n\n10.0\n\n\n\n\n\n\n\n\nccc02s1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc02s2\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc02s4\n\n\nSource\n\n\nPY2\n\n\n10.0\n\n\n\n\n\n\n\n\nccc03s1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc03s2\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc03s3\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\nccc04j1\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nccc04j2\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nccc04j3\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nccc05s1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc05s2\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc05s4\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\nccc06j4\n\n\nSource\n\n\nPY2\n\n\n7.0\n\n\n\n\n\n\n\n\nccc06s2\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc07j1\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nccc07j5\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc07s1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc07s3\n\n\nSource\n\n\nPY2\n\n\n10.0\n\n\n\n\n\n\n\n\nccc07s4\n\n\nSource\n\n\nPY2\n\n\n10.0\n\n\n\n\n\n\n\n\nccc08s1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc08s2\n\n\nSource\n\n\nC\n\n\n5.0\n\n\n\n\n\n\n\n\nccc08s3\n\n\nSource\n\n\nPY2\n\n\n10.0\n\n\n\n\n\n\n\n\nccc08s5\n\n\nSource\n\n\nPY3\n\n\n12.0\n\n\n\n\n\n\n\n\nccc09j1\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nccc09s1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc09s4\n\n\nSource\n\n\nCPP11\n\n\n15.0\n\n\n\n\n\n\n\n\nccc10j1\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nccc10j4\n\n\nSource\n\n\nPY2\n\n\n10.0\n\n\n\n\n\n\n\n\nccc10j5\n\n\nSource\n\n\nPY2\n\n\n10.0\n\n\n\n\n\n\n\n\nccc10s4\n\n\nSource\n\n\nPY3\n\n\n15.0\n\n\n\n\n\n\n\n\nccc11j3\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc11j5\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\nccc11s1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc12s5\n\n\nSource\n\n\nPY2\n\n\n10.0\n\n\n\n\n\n\n\n\nccc13j1\n\n\nSource\n\n\nCPP14\n\n\n3.0\n\n\n\n\n\n\n\n\nccc13j2\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc13s2\n\n\nSource\n\n\nCPP14\n\n\n5.0\n\n\n\n\n\n\n\n\nccc13s4\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\nccc14j2\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nccc14s1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc15j5\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\nccc15s1\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nccc96s1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nccc98s5\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\ncco07p2\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\ncco10p3\n\n\nSource\n\n\nCLANGX\n\n\n20.0\n\n\n\n\n\n\n\n\ncco10p4\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\ncco13p2\n\n\nSource\n\n\nCPP11\n\n\n15.0\n\n\n\n\n\n\n\n\ncco15p2\n\n\nSource\n\n\nPYPY3\n\n\n15.0\n\n\n\n\n\n\n\n\ncco17p5\n\n\nSource\n\n\nCPP11\n\n\n20.0\n\n\n\n\n\n\n\n\nccoprep16q1\n\n\nSource\n\n\nCPP11\n\n\n15.0\n\n\n\n\n\n\n\n\nccoprep1p3\n\n\nSource\n\n\nCPP14\n\n\n25.0\n\n\n\n\n\n\n\n\ncoci06c1p2\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\ncoci06c2p3\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\ncoci06c2p4\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\ncoci06c3p1\n\n\nSource\n\n\nC\n\n\n5.0\n\n\n\n\n\n\n\n\ncoci06c4p3\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\ncoci06c6p1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\ncoci14c2p2\n\n\nSource\n\n\nCPP11\n\n\n6.0\n\n\n\n\n\n\n\n\ndenoun\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\ndmopc13c3p3\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\ndmopc13c3p5\n\n\nSource\n\n\nCPP14\n\n\n15.0\n\n\n\n\n\n\n\n\ndmopc14c1p1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\ndmopc14c1p3\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\ndmopc14c2p3\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\ndmopc14c2p6\n\n\nSource\n\n\nCPP14\n\n\n20.0\n\n\n\n\n\n\n\n\ndmopc14c5p1\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\ndmopc15c3p3\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\ndmopc16c4p1\n\n\nSource\n\n\nCPP11\n\n\n5.0\n\n\n\n\n\n\n\n\nds1\n\n\nSource\n\n\nCPP11\n\n\n10.0\n\n\n\n\n\n\n\n\nds4\n\n\nSource\n\n\nCPP11\n\n\n20.0\n\n\n\n\n\n\n\n\necna05h\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\necna16d\n\n\nSource\n\n\nPY3\n\n\n15.0\n\n\n\n\n\n\n\n\necoo15r1p4\n\n\nSource\n\n\nPY2\n\n\n10.0\n\n\n\n\n\n\n\n\necoo15r2p3\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\necoo16r3p3\n\n\nSource\n\n\nPYPY3\n\n\n10.0\n\n\n\n\n\n\n\n\nfactorial\n\n\nSource\n\n\nC\n\n\n10.0\n\n\n\n\n\n\n\n\ngfssoc16s1\n\n\nSource\n\n\nPY2\n\n\n8.0\n\n\n\n\n\n\n\n\ngfssoc1j5\n\n\nSource\n\n\nPY3\n\n\n12.0\n\n\n\n\n\n\n\n\nhailstone\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nhalloween14p1\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\nhelloworld\n\n\nSource\n\n\nPY3\n\n\n1.0\n\n\n\n\n\n\n\n\nmnyc17p3\n\n\nSource\n\n\nCPP14\n\n\n10.0\n\n\n\n\n\n\n\n\nmnyc17p6\n\n\nSource\n\n\nCPP14\n\n\n17.0\n\n\n\n\n\n\n\n\nodd\n\n\nSource\n\n\nCPP11\n\n\n7.0\n\n\n\n\n\n\n\n\nphantom1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\npiggy\n\n\nSource\n\n\nTEXT\n\n\n7.0\n\n\n\n\n\n\n\n\nprimefactor\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\nrgpc17p1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nrgpc17p2\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\nrgpc17p3\n\n\nSource\n\n\nPY3\n\n\n8.0\n\n\n\n\n\n\n\n\nsandwich\n\n\nSource\n\n\nCPP11\n\n\n5.0\n\n\n\n\n\n\n\n\nscroll\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\nshortest1\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\nsssp\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\ntle16c1p1\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\ntle16c6s1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\ntle16c8p1\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\ntle16c8p2\n\n\nSource\n\n\nPY3\n\n\n3.0\n\n\n\n\n\n\n\n\ntle16c8p5\n\n\nSource\n\n\nPY3\n\n\n15.0\n\n\n\n\n\n\n\n\ntoosimple\n\n\nSource\n\n\nPY3\n\n\n7.0\n\n\n\n\n\n\n\n\ntree2\n\n\nSource\n\n\nPY3\n\n\n15.0\n\n\n\n\n\n\n\n\ntsoc15c2p2\n\n\nSource\n\n\nPY3\n\n\n6.0\n\n\n\n\n\n\n\n\nvalday15p2\n\n\nSource\n\n\nPY3\n\n\n10.0\n\n\n\n\n\n\n\n\nvmss15c1p1\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nvmss7wc16c3p2\n\n\nSource\n\n\nPY3\n\n\n5.0\n\n\n\n\n\n\n\n\nvmss7wc16c5p4\n\n\nSource\n\n\nPY2\n\n\n5.0\n\n\n\n\n\n\n\n\n\n\nCodeforces\n\n\n\n\n\n\n\n\nProblem\n\n\nSource\n\n\nLanguage\n\n\nDifficulty\n\n\n\n\n\n\n\n\n\n\n\n\n810A\n\n\nSource\n\n\nPython 2\n\n\n500.0\n\n\n\n\n\n\n\n\n810B\n\n\nSource\n\n\nPython 3\n\n\n1000.0\n\n\n\n\n\n\n\n\n810C\n\n\nSource\n\n\nGNU C++14\n\n\n1500.0",
            "title": "Problem Solutions"
        },
        {
            "location": "/solutions/#problem-solutions-archive",
            "text": "Here are a set of solutions to some common problems found on competitive programming sites. Please only use these if you are stuck on a problem after you've tried it, or for learning/reference.  Don't copy paste solutions.",
            "title": "Problem Solutions Archive"
        },
        {
            "location": "/solutions/#dmoj",
            "text": "Problem  Source  Language  Difficulty       anoisyclass  Source  PY3  8.0     aplusb  Source  PY3  3.0     bf1  Source  PY3  4.0     bf1hard  Source  PY3  5.0     bf2  Source  PY3  5.0     bf3  Source  PY3  5.0     bf3hard  Source  C  15.0     binary  Source  PY3  5.0     boolean  Source  PY3  4.0     bts16p1  Source  PY3  3.0     bts16p2  Source  PY3  5.0     bts16p3  Source  PY3  7.0     ccc00j2  Source  PY3  3.0     ccc00j3  Source  PY3  5.0     ccc00j4  Source  PY3  7.0     ccc00s4  Source  PY3  10.0     ccc01j2  Source  PY3  3.0     ccc01s3  Source  PY3  10.0     ccc01s5  Source  PY2  10.0     ccc02s1  Source  PY3  5.0     ccc02s2  Source  PY3  5.0     ccc02s4  Source  PY2  10.0     ccc03s1  Source  PY3  5.0     ccc03s2  Source  PY3  5.0     ccc03s3  Source  PY3  10.0     ccc04j1  Source  PY3  3.0     ccc04j2  Source  PY3  3.0     ccc04j3  Source  PY3  3.0     ccc05s1  Source  PY3  5.0     ccc05s2  Source  PY3  5.0     ccc05s4  Source  PY3  10.0     ccc06j4  Source  PY2  7.0     ccc06s2  Source  PY3  5.0     ccc07j1  Source  PY3  3.0     ccc07j5  Source  PY3  5.0     ccc07s1  Source  PY3  5.0     ccc07s3  Source  PY2  10.0     ccc07s4  Source  PY2  10.0     ccc08s1  Source  PY3  5.0     ccc08s2  Source  C  5.0     ccc08s3  Source  PY2  10.0     ccc08s5  Source  PY3  12.0     ccc09j1  Source  PY3  3.0     ccc09s1  Source  PY3  5.0     ccc09s4  Source  CPP11  15.0     ccc10j1  Source  PY3  3.0     ccc10j4  Source  PY2  10.0     ccc10j5  Source  PY2  10.0     ccc10s4  Source  PY3  15.0     ccc11j3  Source  PY3  5.0     ccc11j5  Source  PY3  7.0     ccc11s1  Source  PY3  5.0     ccc12s5  Source  PY2  10.0     ccc13j1  Source  CPP14  3.0     ccc13j2  Source  PY3  5.0     ccc13s2  Source  CPP14  5.0     ccc13s4  Source  PY3  10.0     ccc14j2  Source  PY3  3.0     ccc14s1  Source  PY3  5.0     ccc15j5  Source  PY3  10.0     ccc15s1  Source  PY3  3.0     ccc96s1  Source  PY3  5.0     ccc98s5  Source  PY3  10.0     cco07p2  Source  PY3  10.0     cco10p3  Source  CLANGX  20.0     cco10p4  Source  PY3  10.0     cco13p2  Source  CPP11  15.0     cco15p2  Source  PYPY3  15.0     cco17p5  Source  CPP11  20.0     ccoprep16q1  Source  CPP11  15.0     ccoprep1p3  Source  CPP14  25.0     coci06c1p2  Source  PY3  5.0     coci06c2p3  Source  PY3  7.0     coci06c2p4  Source  PY3  7.0     coci06c3p1  Source  C  5.0     coci06c4p3  Source  PY3  5.0     coci06c6p1  Source  PY3  5.0     coci14c2p2  Source  CPP11  6.0     denoun  Source  PY3  5.0     dmopc13c3p3  Source  PY3  10.0     dmopc13c3p5  Source  CPP14  15.0     dmopc14c1p1  Source  PY3  5.0     dmopc14c1p3  Source  PY3  7.0     dmopc14c2p3  Source  PY3  7.0     dmopc14c2p6  Source  CPP14  20.0     dmopc14c5p1  Source  PY3  3.0     dmopc15c3p3  Source  PY3  7.0     dmopc16c4p1  Source  CPP11  5.0     ds1  Source  CPP11  10.0     ds4  Source  CPP11  20.0     ecna05h  Source  PY3  10.0     ecna16d  Source  PY3  15.0     ecoo15r1p4  Source  PY2  10.0     ecoo15r2p3  Source  PY3  10.0     ecoo16r3p3  Source  PYPY3  10.0     factorial  Source  C  10.0     gfssoc16s1  Source  PY2  8.0     gfssoc1j5  Source  PY3  12.0     hailstone  Source  PY3  5.0     halloween14p1  Source  PY3  7.0     helloworld  Source  PY3  1.0     mnyc17p3  Source  CPP14  10.0     mnyc17p6  Source  CPP14  17.0     odd  Source  CPP11  7.0     phantom1  Source  PY3  5.0     piggy  Source  TEXT  7.0     primefactor  Source  PY3  7.0     rgpc17p1  Source  PY3  5.0     rgpc17p2  Source  PY3  7.0     rgpc17p3  Source  PY3  8.0     sandwich  Source  CPP11  5.0     scroll  Source  PY3  3.0     shortest1  Source  PY3  7.0     sssp  Source  PY3  7.0     tle16c1p1  Source  PY3  3.0     tle16c6s1  Source  PY3  5.0     tle16c8p1  Source  PY3  3.0     tle16c8p2  Source  PY3  3.0     tle16c8p5  Source  PY3  15.0     toosimple  Source  PY3  7.0     tree2  Source  PY3  15.0     tsoc15c2p2  Source  PY3  6.0     valday15p2  Source  PY3  10.0     vmss15c1p1  Source  PY3  5.0     vmss7wc16c3p2  Source  PY3  5.0     vmss7wc16c5p4  Source  PY2  5.0",
            "title": "DMOJ"
        },
        {
            "location": "/solutions/#codeforces",
            "text": "Problem  Source  Language  Difficulty       810A  Source  Python 2  500.0     810B  Source  Python 3  1000.0     810C  Source  GNU C++14  1500.0",
            "title": "Codeforces"
        },
        {
            "location": "/about/",
            "text": "Hi\n\n\nWe are dank",
            "title": "About"
        },
        {
            "location": "/about/#hi",
            "text": "We are dank",
            "title": "Hi"
        }
    ]
}