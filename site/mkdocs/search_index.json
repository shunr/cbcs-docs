{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to Colonel By CS Docs\n\n\nIntroduction\n\n\nCompetitive programming is very fun and not hard at all to get into. It gives a great feeling of satisfaction upon answering a question correctly. We have only been practicing for half a year and are already quite experienced. If you find it interesting and put in the work, you can easily be top level competitors (CCO)\n\n\nWe all use both C++ and Python when solving problems. The two languages we would most recommend are C++ and Java. C++ has much less verbose syntax and is thus faster to write in most cases.\n\n\nThis is the order in which we learned concepts. There is no perfect order to follow, however some topics are much easier when you know others.\n\n\nImplementation (become familiar and comfortable with a language)\nRecursion\nUnderstanding basic graph theory and Breadth First Search/Depth First Search\nGreedy algorithms\nDynamic Programming\nSingle Source Shortest Path (Dijkstra\u2019s and Bellman-Ford)\nLearn about different containers (learn standard libraries, they\u2019re very powerful)\nMinimum Spanning Trees\nData Structures (Binary Indexed Tree, Segment Tree, Binary Search Tree)\nMax flow MIN CUT LEMMA WOOOOO MATHEMATICS",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-colonel-by-cs-docs",
            "text": "Introduction  Competitive programming is very fun and not hard at all to get into. It gives a great feeling of satisfaction upon answering a question correctly. We have only been practicing for half a year and are already quite experienced. If you find it interesting and put in the work, you can easily be top level competitors (CCO)  We all use both C++ and Python when solving problems. The two languages we would most recommend are C++ and Java. C++ has much less verbose syntax and is thus faster to write in most cases.  This is the order in which we learned concepts. There is no perfect order to follow, however some topics are much easier when you know others.  Implementation (become familiar and comfortable with a language)\nRecursion\nUnderstanding basic graph theory and Breadth First Search/Depth First Search\nGreedy algorithms\nDynamic Programming\nSingle Source Shortest Path (Dijkstra\u2019s and Bellman-Ford)\nLearn about different containers (learn standard libraries, they\u2019re very powerful)\nMinimum Spanning Trees\nData Structures (Binary Indexed Tree, Segment Tree, Binary Search Tree)\nMax flow MIN CUT LEMMA WOOOOO MATHEMATICS",
            "title": "Welcome to Colonel By CS Docs"
        },
        {
            "location": "/recursion/",
            "text": "Recursion\n\n\n\n\nRecursion is a fundamental concept that is incredibly useful in competitive programming. It is commonly used to solve problems in graph theory and implemented in algorithms such as \ndepth and beadth first search\n. Recursion also provides a very simple and straightforward way of thinking about \ndynamic programming\n. Recursion is very powerful and necessary for many problems.\n\n\nThe idea with recursion is that a function will be called, but in order to return a value it relies on the same function being called. It will continue to \u201cwait\u201d until a base case is reached, where afterwards all of the other functions can return values.\n\n\nExample\n\n\nA common example is a recursive solution to finding the nth Fibonacci number\n\n\nfib(n) {\n    if (n == 0 || n == 1)\n        return 1\n    return fib(n-1) + fib(n-2)\n}\n\n\n\n\nExplanation\n\n\nThis function begins with the parameter \nn\n, the answer in the first call of the function depends on the previous two Fibonacci numbers since \nfib(n) = fib(n-1) + fib(n-2)\n. This means that the function will be executed again to solve for these two numbers, since none of these numbers are known yet, it will continue calling this function until the base case is reached. In mathematical terms, the Fibonacci sequence is based on a formula that is based on the first and second terms. In math class you have probably learned about such recursive sequences, the value of the next term depends on the current term or terms.\n\n\nPractice problems\n\n\n\n\nCCC '13 S3 - Chances of Winning\n\n\nVM7WC '16 #4 Silver - Tests or Test Cases?\n\n\nCCC '96 S3 - Pattern Generator\n\n\nCCC '03 S3 - Floor Plan\n *\nincludes graph theory",
            "title": "Recursion"
        },
        {
            "location": "/recursion/#recursion",
            "text": "Recursion is a fundamental concept that is incredibly useful in competitive programming. It is commonly used to solve problems in graph theory and implemented in algorithms such as  depth and beadth first search . Recursion also provides a very simple and straightforward way of thinking about  dynamic programming . Recursion is very powerful and necessary for many problems.  The idea with recursion is that a function will be called, but in order to return a value it relies on the same function being called. It will continue to \u201cwait\u201d until a base case is reached, where afterwards all of the other functions can return values.",
            "title": "Recursion"
        },
        {
            "location": "/recursion/#example",
            "text": "A common example is a recursive solution to finding the nth Fibonacci number  fib(n) {\n    if (n == 0 || n == 1)\n        return 1\n    return fib(n-1) + fib(n-2)\n}",
            "title": "Example"
        },
        {
            "location": "/recursion/#explanation",
            "text": "This function begins with the parameter  n , the answer in the first call of the function depends on the previous two Fibonacci numbers since  fib(n) = fib(n-1) + fib(n-2) . This means that the function will be executed again to solve for these two numbers, since none of these numbers are known yet, it will continue calling this function until the base case is reached. In mathematical terms, the Fibonacci sequence is based on a formula that is based on the first and second terms. In math class you have probably learned about such recursive sequences, the value of the next term depends on the current term or terms.",
            "title": "Explanation"
        },
        {
            "location": "/recursion/#practice-problems",
            "text": "CCC '13 S3 - Chances of Winning  VM7WC '16 #4 Silver - Tests or Test Cases?  CCC '96 S3 - Pattern Generator  CCC '03 S3 - Floor Plan  * includes graph theory",
            "title": "Practice problems"
        }
    ]
}